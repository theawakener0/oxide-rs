<Context>
You receive a selection in neovim that you need to replace with new code.
The selection's contents may contain notes, incorporate the notes every time if there are some.
consider the context of the selection and what you are suppose to be implementing
<SELECTION_LOCATION>
range(point(23,1),point(31,2))
</SELECTION_LOCATION>
<SELECTION_CONTENT>
pub fn format_token_count(n: usize) -> String {
    if n >= 1_000_000 {
        format!("{:.1}M", n as f64 / 1_000_000.0)
    } else if n >= 1_000 {
        format!("{:.1}k", n as f64 / 1_000.0)
    } else {
        n.to_string()
    }
}
</SELECTION_CONTENT>
<FILE_CONTAINING_SELECTION>
use std::io::{self, Write};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread::{self, JoinHandle};
use std::time::{Duration, Instant};

use crossterm::{
    cursor::MoveToColumn,
    execute,
    style::{Attribute, Print, ResetColor, SetAttribute, SetForegroundColor},
    terminal::{Clear, ClearType},
};

use super::theme::Theme;

const THINKING_FRAMES: &[&str] = &[
    "ðŸ¦€ðŸ’­ Thinking.",
    "ðŸ¦€ðŸ’­ Thinking..",
    "ðŸ¦€ðŸ’­ Thinking...",
    "ðŸ¦€ðŸ’­ Thinking",
];

pub fn format_token_count(n: usize) -> String {
    if n >= 1_000_000 {
        format!("{:.1}M", n as f64 / 1_000_000.0)
    } else if n >= 1_000 {
        format!("{:.1}k", n as f64 / 1_000.0)
    } else {
        n.to_string()
    }
}

pub struct ThinkingSpinner {
    running: Arc<AtomicBool>,
    handle: Option<JoinHandle<()>>,
}

impl ThinkingSpinner {
    pub fn new() -> Self {
        let running = Arc::new(AtomicBool::new(true));

        let handle = thread::spawn({
            let running = running.clone();
            move || {
                let mut stdout = io::stdout();
                let mut i = 0usize;

                while running.load(Ordering::Relaxed) {
                    let frame = THINKING_FRAMES[i % THINKING_FRAMES.len()];

                    execute!(
                        stdout,
                        MoveToColumn(0),
                        Clear(ClearType::CurrentLine),
                        SetForegroundColor(Theme::ACCENT_CYAN),
                        Print(frame),
                        ResetColor
                    )
                    .ok();

                    stdout.flush().ok();
                    thread::sleep(Duration::from_millis(200));
                    i = i.wrapping_add(1);
                }
            }
        });

        Self {
            running,
            handle: Some(handle),
        }
    }

    pub fn stop(mut self) {
        self.running.store(false, Ordering::Relaxed);
        if let Some(h) = self.handle.take() {
            h.join().ok();
        }

        let mut stdout = io::stdout();
        execute!(stdout, MoveToColumn(0), Clear(ClearType::CurrentLine)).ok();
    }
}

impl Default for ThinkingSpinner {
    fn default() -> Self {
        Self::new()
    }
}

impl Drop for ThinkingSpinner {
    fn drop(&mut self) {
        self.running.store(false, Ordering::Relaxed);
    }
}

pub fn strip_special_tokens(input: &str) -> String {
    let mut result = input.to_string();

    let patterns = [
        "<|im_start|>user",
        "<|im_start|>assistant",
        "<|im_start|>system",
        "<|im_start|>",
        "<|im_end|>",
        "<|end|>",
        "<|start|>",
        "<|sep|>",
        "<s>",
        "</s>",
        "<pad>",
    ];

    for pattern in &patterns {
        result = result.replace(pattern, "");
    }

    result = result.replace("<br>", "\n");
    result = result.replace("\\n", "\n");

    while result.contains("\n\n\n") {
        result = result.replace("\n\n\n", "\n\n");
    }

    result.trim().to_string()
}

pub struct StreamOutput {
    stdout: io::Stdout,
    first_token: bool,
    start_time: Instant,
    token_count: usize,
    context_used: usize,
    context_limit: usize,
    prompt_tokens: usize,
    finished: bool,
}

impl StreamOutput {
    pub fn new() -> Self {
        Self {
            stdout: io::stdout(),
            first_token: true,
            start_time: Instant::now(),
            token_count: 0,
            context_used: 0,
            context_limit: 4096,
            prompt_tokens: 0,
            finished: false,
        }
    }

    pub fn set_context(&mut self, used: usize, limit: usize) {
        self.context_used = used;
        self.context_limit = limit;
    }

    pub fn set_prompt_tokens(&mut self, count: usize) {
        self.prompt_tokens = count;
    }

    pub fn print_token(&mut self, token: &str) {
        if self.first_token {
            self.first_token = false;
        }

        self.token_count += 1;

        let cleaned = strip_special_tokens(token);

        if !cleaned.is_empty() {
            // Add space if needed for proper word spacing
            let output = if !cleaned.starts_with(' ')
                && !cleaned.starts_with('\n')
                && self.token_count > 1
            {
                format!(" {}", cleaned)
            } else {
                cleaned
            };
            execute!(self.stdout, Print(&output)).ok();
            self.stdout.flush().ok();
        }
    }

    pub fn finish(&mut self) {
        if self.finished {
            return;
        }
        self.finished = true;

        let elapsed = self.start_time.elapsed();
        let tokens_per_sec = if elapsed.as_secs_f64() > 0.0 {
            self.token_count as f64 / elapsed.as_secs_f64()
        } else {
            0.0
        };

        let final_context = self.context_used + self.prompt_tokens + self.token_count;

        execute!(
            self.stdout,
            ResetColor,
            Print("\n"),
            SetForegroundColor(Theme::IRON_GRAY),
            Print("  â–¸ "),
            ResetColor,
            SetForegroundColor(Theme::TEXT_SECONDARY),
            Print(format!(
                "{} tokens â€¢ {:.1} tok/s â€¢ Context: {}/{} â€¢ {:.1}s",
                self.token_count,
                tokens_per_sec,
                format_token_count(final_context),
                format_token_count(self.context_limit),
                elapsed.as_secs_f64()
            )),
            ResetColor,
            Print("\n")
        )
        .ok();
    }
}

impl Default for StreamOutput {
    fn default() -> Self {
        Self::new()
    }
}

pub struct PromptDisplay {
    stdout: io::Stdout,
}

impl PromptDisplay {
    pub fn new() -> Self {
        Self {
            stdout: io::stdout(),
        }
    }

    pub fn show_user_input(&mut self, text: &str) {
        execute!(
            self.stdout,
            Print("\n"),
            SetForegroundColor(Theme::RUST_ORANGE),
            SetAttribute(Attribute::Bold),
            Print("â–¸ "),
            ResetColor,
            SetForegroundColor(Theme::TEXT_PRIMARY),
            Print(text),
            ResetColor,
            Print("\n\n")
        )
        .ok();
        self.stdout.flush().ok();
    }

    pub fn show_input_prompt(&mut self) {
        execute!(
            self.stdout,
            Print("\n"),
            SetForegroundColor(Theme::RUST_ORANGE),
            SetAttribute(Attribute::Bold),
            Print("â–¸"),
            ResetColor,
            Print(" ")
        )
        .ok();
        self.stdout.flush().ok();
    }
}

impl Default for PromptDisplay {
    fn default() -> Self {
        Self::new()
    }
}

pub fn print_welcome() {
    let mut stdout = io::stdout();
    execute!(
        stdout,
        SetForegroundColor(Theme::IRON_GRAY),
        Print("  Type your message and press Enter. "),
        SetForegroundColor(Theme::TEXT_SECONDARY),
        Print("Ctrl+C"),
        ResetColor,
        SetForegroundColor(Theme::IRON_GRAY),
        Print(" to exit.\n"),
        ResetColor
    )
    .ok();
}
</FILE_CONTAINING_SELECTION>

</Context>
<Prompt>
 I want to change the format from 128.0Kk to 128K
</Prompt>

<Location><File>/home/theawakener/Projects/oxide/src/cli/stream.rs</File><Function>range(point(23,1),point(31,2))</Function></Location>
<FunctionText>pub fn format_token_count(n: usize) -> String {
    if n >= 1_000_000 {
        format!("{:.1}M", n as f64 / 1_000_000.0)
    } else if n >= 1_000 {
        format!("{:.1}k", n as f64 / 1_000.0)
    } else {
        n.to_string()
    }
}</FunctionText>
<TEMP_FILE>./tmp/99-3252</TEMP_FILE>
<MustObey>
NEVER alter any file other than TEMP_FILE.
never provide the requested changes as conversational output. Return only the code.
ONLY provide requested changes by writing the change to TEMP_FILE

never attempt to read TEMP_FILE.
It is purely for output.
Previous contents, which may not exist, can be written over without worry
After writing TEMP_FILE once you should be done.  Be done and end the session.

</MustObey>